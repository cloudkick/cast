/*
 * Licensed to Cloudkick, Inc ('Cloudkick') under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * p work for additional information regarding copyright ownership.
 * Cloudkick licenses p file to You under the Apache License, Version 2.0
 * (the "License"); you may not use p file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * USAGE NOTE:
 *
 * This script generates, in an embarrassingly crude fashion, markdown
 * documentation for the cast client and each of its commands and sub-commands.
 * This documentation effectively equivalent to the help output generated by
 * the cast client itself, but generates markdown intended to be included in
 * the cast website. Note that the output is slightly dependent on the hyde
 * engines templating for URL generation.
 *
 * Example Usage:
 *   node docgen.js ../../cast-site/content/docs/client
 */

var pathSetup = require('../lib/util/path_setup').pathSetup;
pathSetup();

var sys = require('sys');
var path = require('path');
var fs = require('fs');

var sprintf = require('extern/sprintf').sprintf;

var fsutil = require('util/fs');
var term = require('util/terminal');
var parser = require('cast-client/parser');

var WIDTH = 80;

function DocumentGenerator(filename) {
  this.depth = 2;
  this.text = '';
  this.filename = filename;
}

DocumentGenerator.prototype.emit = function(text) {
  this.text += text;
};

DocumentGenerator.prototype.begin = function() {
  this.emit('{% markdown %}\n');
};

DocumentGenerator.prototype.save = function() {
  var self = this;
  console.log(path.dirname(self.filename));
  fsutil.mkdir(path.dirname(self.filename), 0755, function() {
    fs.writeFile(self.filename, self.text + '{% endmarkdown %}\n');
  });
};

DocumentGenerator.prototype.beginSection = function(header) {
  this.depth++;
  this.emit('\n' + new Array(this.depth + 1).join('#') + ' ' + header + '\n\n');
};

DocumentGenerator.prototype.endSection = function() {
  this.depth--;
};

DocumentGenerator.prototype.emitCode = function(lang, code) {
  this.emit('{% endmarkdown %}\n');
  this.emit('{% syntax ' + lang + ' %}\n');
  this.emit(code + '\n');
  this.emit('{% endsyntax %}\n');
  this.emit('{% markdown %}\n');
};

DocumentGenerator.prototype.emitText = function(text) {
  var chunk, splitIndex;
  var remaining = text;

  while (remaining.length > WIDTH) {
    chunk = remaining.slice(0, WIDTH);
    splitIndex = chunk.lastIndexOf(' ');
    chunk = chunk.slice(0, splitIndex);
    this.text += chunk + '\n';
    remaining = remaining.substr(splitIndex + 1);
  }

  this.text += remaining + '\n';
};

function genCommandList(p, d, heading, commands) {
  var i = 0;

  function cap(str) {
    return str.slice(0, 1).toUpperCase() + str.slice(1);
  }

  d.beginSection(heading);
  for (i = 0; i < commands.length; i++) {
    d.emit(sprintf('* [%s]({{ page.url }}%s)\n', cap(commands[i]), commands[i]));
  }
  d.endSection();

  d.emit('\n');
}

function genCommandDoc(p, d, command, subCommand) {
  var i, option, title;
  var config = p.getModuleForCommand(command, subCommand).config;

  p.mergeGlobalOptions(config);

  // Description
  d.emitText(config.longDescription);

  // Synopsis
  d.beginSection('Synopsis');
  d.emitCode('text', p.getCommandUsageString(command, subCommand));
  d.endSection();

  // Required Arguments
  if (config.requiredArguments.length > 0) {
    d.beginSection('Required Arguments');
    for (i = 0; i < config.requiredArguments.length; i++) {
      d.emit('__' + config.requiredArguments[i][0].toUpperCase() + '__\n\n');
      d.emitText(config.requiredArguments[i][1] + '\n');
    }
    d.endSection();
  }

  // Optional Arguments
  if (config.optionalArguments.length > 0) {
    d.beginSection('Optional Arguments');
    for (i = 0; i < config.optionalArguments.length; i++) {
      d.emit('__' + config.optionalArguments[i][0].toUpperCase() + '__\n\n');
      d.emitText(config.optionalArguments[i][1] + '\n');
    }
    d.endSection();
  }

  // Options
  if (config.options && config.options.length > 0) {
    d.beginSection('Options');
    for (i = 0; i < config.options.length; i++) {
      option = config.options[i];
      title = option.title || option.dest;

      // Print out the option format string, for example "--foo <bar>, -f <bar>"
      if (option.action === 'store' || option.action === 'append') {
        d.emit(option.names.map(function(name) {
          return sprintf('__%s__ &lt;%s&gt;', name, title);
        }).join(', '));
      }

      // Or "--foo, -f" for boolean options
      else {
        d.emit(option.names.map(function(name) {
          return sprintf('__%s__', name);
        }).join(', '));
      }

      d.emit('\n\n');
      d.emitText(option.desc);
      d.emit('\n');
    }
    d.endSection();
  }
}

function main() {
  if (process.argv.length < 3) {
    console.log('Error: No doc dir specified');
    process.exit(0);
  }

  var name, sname, config, i, d, fp;
  var p = parser.getParser();
  var normalCommands = p._normalCommands;
  var globalCommands = p._globalCommands.filter(function(command) {
    return command !== 'completion';
  });

  // Client Help Contents
  fp = path.join(process.argv[2], 'doc.stub');
  d = new DocumentGenerator(fp);

  d.begin();
  genCommandList(p, d, 'Commands', globalCommands.concat(Object.keys(normalCommands)));
  d.save();

  for (name in normalCommands) {
    // Command Contents
    fp = path.join(process.argv[2], name, 'doc.stub');
    d = new DocumentGenerator(fp);

    d.begin();
    genCommandList(p, d, 'Sub-Commands', normalCommands[name]);
    d.save();

    // Docs for each sub-command
    for (i = 0; i < normalCommands[name].length; i++) {
      sname = normalCommands[name][i];
      fp = path.join(process.argv[2], name, sname, 'doc.stub');
      d = new DocumentGenerator(fp);

      d.begin();
      genCommandDoc(p, d, name, sname);
      d.save();
    }
  }

  // Docs for each global command
  for (i = 0; i < globalCommands.length; i++) {
    name = globalCommands[i];
    fp = path.join(process.argv[2], name, 'doc.stub');
    d = new DocumentGenerator(fp);

    d.begin();
    genCommandDoc(p, d, name);
    d.save();
  }
}

main();
